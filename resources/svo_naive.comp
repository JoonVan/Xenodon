#version 450

#include "common.glsl"
#include "octree.glsl"

const float MIN_STEP_SIZE = 0.00001;

vec2 aabb_intersect(vec3 bmin, vec3 bmax, vec3 ro, vec3 rrd) {
    vec3 tbot = (bmin - ro) * rrd;
    vec3 ttop = (bmax - ro) * rrd;
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);
    vec2 t = max(tmin.xx, tmin.yz);
    float t0 = max(t.x, t.y);
    t = min(tmax.xx, tmax.yz);
    float t1 = min(t.x, t.y);
    return vec2(t0, t1);
}

uint find(vec3 pos, out vec3 base, out float side) {
    float extent = 1.0;

    uint index = 0;
    vec3 offset = vec3(0);

    while (true) {
        if (model.nodes[index].is_leaf_depth >= LEAF) {
            base = offset;
            side = extent;
            return index;
        }

        extent *= 0.5;
        bvec3 mask = greaterThanEqual(pos, offset + extent);
        int child = int(mask.x) * 4 + int(mask.y) * 2 + int(mask.z);
        offset += vec3(mask) * vec3(extent);
        index = model.nodes[index].children[child];
    }
}

vec4 trace(vec3 ro, vec3 rd) {
    vec3 rrd = 1.0 / rd;
    vec3 bias = rrd * ro;

    vec3 box_min = -bias;
    vec3 box_max = rrd - bias;

    float t_min = max_elem(min(box_min, box_max));
    float t_max = min_elem(max(box_min, box_max));

    if (t_min > t_max) {
        // Ray misses bounding cube
        return vec4(0);
    }

    t_min = max(t_min, 0);

    vec4 total = vec4(0);
    float density = voxel_density(rd);

    float t = t_min + MIN_STEP_SIZE;

    while (t < t_max) {
        vec3 p = t * rd + ro;
        vec3 offset;
        float side;
        uint node = find(p, offset, side);

        vec2 isect = aabb_intersect(vec3(0), vec3(side), ro - offset, rrd);
        isect.x = max(isect.x, 0);
        float step = max(isect.y - isect.x, MIN_STEP_SIZE);
        t += step;

        vec4 color = unpackUnorm4x8(model.nodes[node].color);
        total += color * step * density;
    }

    return total;
}

void main() {
    uvec2 index = gl_GlobalInvocationID.xy;

    if (any(greaterThanEqual(index, uniforms.output_region.extent))) {
        return;
    }

    ivec2 pixel = uniforms.output_region.offset + ivec2(index);
    vec2 uv = vec2(pixel - uniforms.display_region.offset) / vec2(uniforms.display_region.extent);

    vec3 ro = push.camera.translation.xyz;
    vec3 rd = ray(uv);

    vec4 color = trace(ro, rd);

    imageStore(render_target, ivec2(index), vec4(color.rgb, 1));
}
