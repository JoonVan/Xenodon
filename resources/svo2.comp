#version 450

struct Node {
    uint children[8];
    uint color;
    uint is_leaf_depth;
};

struct Rect {
    ivec2 offset;
    uvec2 extent;
};

layout(local_size_x = 8, local_size_y = 8) in;

layout(push_constant) uniform PushConstant {
    float time;
} push;

layout(binding = 0) readonly uniform UniformBuffer {
    Rect output_region;
    Rect display_region;
} uniforms;

layout(binding = 1) readonly buffer Octree {
    Node nodes[];
} model;

layout(binding = 2, rgba8) restrict writeonly uniform image2D render_target;

const uint LEAF = 1 << 31;

vec3 ray(vec3 dir, vec3 up, vec2 uv) {
    uv -= 0.5;
    uv.y *= float(uniforms.display_region.extent.y) / float(uniforms.display_region.extent.x);

    vec3 right = normalize(cross(up, dir));
    up = normalize(cross(right, dir));

    return normalize(uv.x * right + uv.y * up + dir);
}

float min_elem(vec3 v) {
    return min(v.x, min(v.y, v.z));
}

float max_elem(vec3 v) {
    return max(v.x, max(v.y, v.z));
}

vec4 trace(vec3 ro, vec3 rd) {
    const uint float_mantissa_size = 23;
    const float epsilon = exp2(-float(float_mantissa_size));

    // Adjust the ray direction if one of its values is close to 0
    rd = mix(rd, step(rd, vec3(0)) * epsilon * 2.0 - epsilon, lessThan(abs(rd), vec3(epsilon)));

    vec3 rrd = 1.0 / rd;
    vec3 bias = rrd * ro;

    vec3 pos = vec3(1);
    float side = 1.0;

    uint stack_index = float_mantissa_size - 1;

    // Extra slot to prevent out-of-bounds read
    uint node_stack[float_mantissa_size + 1];
    uint child_index_stack[float_mantissa_size + 1];

    node_stack[float_mantissa_size] = 0;
    child_index_stack[float_mantissa_size] = 8;

    uint node = 0;
    uint idx = 0;

    vec4 total_color = vec4(0);

    while (stack_index < float_mantissa_size) {
        vec3 box_min = pos * rrd - bias;
        vec3 box_max = (pos + side) * rrd - bias;

        float t_min = max_elem(min(box_min, box_max));
        float t_max = min_elem(max(box_min, box_max));

        if (t_min <= t_max) {
            // This cube is hit
            // sum its children

            if (model.nodes[node].is_leaf_depth >= LEAF) {
                vec4 color = unpackUnorm4x8(model.nodes[node].color);
                total_color += color * (t_max - t_min);
            } else {
                node_stack[stack_index] = node;
                child_index_stack[stack_index] = idx;

                side *= 0.5;
                --stack_index;
                idx = 0;

                // Move to the first child, we dont need to change the coordinate here
                node = model.nodes[node].children[0];
                continue;
            }
        }

        while (idx == 7 && stack_index < float_mantissa_size - 1) {
            ++stack_index;
            side *= 2.0;
            node = node_stack[stack_index];
            idx = child_index_stack[stack_index];
        }

        if (idx == 7 || stack_index == float_mantissa_size - 1) {
            return total_color;
        }

        pos -= mod(pos, side * 2.0);

        ++idx;

        pos += mix(vec3(0), vec3(side), notEqual(uvec3(idx) & uvec3(4, 2, 1), uvec3(0)));

        uint parent = node_stack[stack_index + 1];
        node = model.nodes[parent].children[idx];
    }
}

void main() {
    uvec2 index = gl_GlobalInvocationID.xy;

    if (any(greaterThanEqual(index, uniforms.output_region.extent))) {
        return;
    }

    ivec2 pixel = uniforms.output_region.offset + ivec2(index);
    vec2 uv = vec2(pixel - uniforms.display_region.offset) / vec2(uniforms.display_region.extent);

    float t = push.time * 1.2;
    vec3 center = vec3(1.5, 1.5, 1.5);

    vec3 ro = center + vec3(sin(t), 0, cos(t)) * 3;
    vec3 rd = normalize(center - ro);
    rd = ray(rd, vec3(0, 1, 0), uv);

    vec4 color = trace(ro, rd);

    imageStore(render_target, ivec2(index), vec4(color.rgb, 1));
}
