#version 450

#include "common.glsl"
#include "octree.glsl"

vec4 trace(vec3 ro, vec3 rd) {
    vec3 rrd = 1.0 / rd;
    vec3 bias = rrd * ro;

    const uint cast_stack_depth = FLOAT_MANTISSA_BITS;

    int stack_index = int(cast_stack_depth - 1);

    // Extra slot to prevent out-of-bounds read
    uint node_stack[cast_stack_depth + 1];
    uint child_index_stack[cast_stack_depth + 1];
    float side_stack[cast_stack_depth + 1];

    node_stack[cast_stack_depth] = 0;
    child_index_stack[cast_stack_depth] = 8;

    uint parent_idx = 0;
    Node parent = model.nodes[parent_idx];

    uint idx = 0;
    vec3 pos = vec3(1);
    float side = 0.5;

    vec4 total_color = vec4(0);
    float density = voxel_density(rd);

    uint i = 0;

    while (stack_index < cast_stack_depth && i < 5000) {
        ++i;

        vec3 box_min = pos * rrd - bias;
        vec3 box_max = (pos + side) * rrd - bias;

        float t_min = max_elem(min(box_min, box_max));
        float t_max = min_elem(max(box_min, box_max));

        if (t_min <= t_max) {
            uint child = parent.children[idx];

            if (model.nodes[child].is_leaf_depth >= LEAF_MASK) {
                vec4 color = unpackUnorm4x8(model.nodes[child].color);
                total_color += color * (t_max - t_min) * density;
            } else {
                if (idx != 7) {
                    node_stack[stack_index] = parent_idx;
                    child_index_stack[stack_index] = idx;
                    side_stack[stack_index] = side;
                    --stack_index;
                }

                side *= 0.5;

                parent_idx = child;
                parent = model.nodes[parent_idx];

                idx = 0;
                continue;
            }
        }

        if (idx == 7) {
            ++stack_index;

            if (stack_index >= cast_stack_depth) {
                return total_color;
            }

            parent_idx = node_stack[stack_index];
            idx = child_index_stack[stack_index];
            side = side_stack[stack_index];

            parent = model.nodes[parent_idx];
        }

        pos -= mod(pos, side * 2.0);
        ++idx;
        pos += mix(vec3(0), vec3(side), notEqual(uvec3(idx) & uvec3(4, 2, 1), uvec3(0)));
    }

    return vec4(0, 1, 0, 1);
}

void main() {
    uvec2 index = gl_GlobalInvocationID.xy;

    if (any(greaterThanEqual(index, uniforms.output_region.extent))) {
        return;
    }

    ivec2 pixel = uniforms.output_region.offset + ivec2(index);
    vec2 uv = vec2(pixel - uniforms.display_region.offset) / vec2(uniforms.display_region.extent);

    vec3 ro = push.camera.translation.xyz + vec3(1);
    vec3 rd = ray(uv);

    vec4 color = trace(ro, rd);

    imageStore(render_target, ivec2(index), vec4(color.rgb, 1));
}
