#version 450

#include "raytrace_shader.glsl"
#include "octree.glsl"

float min_elem(vec3 v) {
    return min(v.x, min(v.y, v.z));
}

float max_elem(vec3 v) {
    return max(v.x, max(v.y, v.z));
}

vec4 trace(vec3 ro, vec3 rd) {
    const uint float_mantissa_size = 23;
    const float epsilon = 0.00001;

    // Adjust the ray direction if one of its values is close to 0
    rd = mix(rd, step(rd, vec3(0)) * epsilon * 2.0 - epsilon, lessThan(abs(rd), vec3(epsilon)));

    if (any(lessThan(abs(rd), vec3(epsilon)))) {
        return vec4(1, 0, 1, 1);
    }

    vec3 rrd = 1.0 / rd;
    vec3 bias = rrd * ro;

    int stack_index = int(float_mantissa_size - 1);

    // Extra slot to prevent out-of-bounds read
    uint node_stack[float_mantissa_size + 1];
    uint child_index_stack[float_mantissa_size + 1];
    float side_stack[float_mantissa_size + 1];

    node_stack[float_mantissa_size] = 0;
    child_index_stack[float_mantissa_size] = 8;

    uint parent_idx = 0;
    Node parent = model.nodes[parent_idx];

    uint idx = 0;
    vec3 pos = vec3(1);
    float side = 0.5;

    vec4 total_color = vec4(0);

    uint i = 0;

    while (stack_index < float_mantissa_size && i < 1000) {
        ++i;

        vec3 box_min = pos * rrd - bias;
        vec3 box_max = (pos + side) * rrd - bias;

        float t_min = max_elem(min(box_min, box_max));
        float t_max = min_elem(max(box_min, box_max));

        if (t_min <= t_max) {
            uint child = parent.children[idx];

            if (model.nodes[child].is_leaf_depth >= LEAF) {
                vec4 color = unpackUnorm4x8(model.nodes[child].color);
                total_color += color * (t_max - t_min) * uniforms.params.density;
            } else {
                if (idx != 7) {
                    node_stack[stack_index] = parent_idx;
                    child_index_stack[stack_index] = idx;
                    side_stack[stack_index] = side;
                    --stack_index;
                }

                side *= 0.5;

                parent_idx = child;
                parent = model.nodes[parent_idx];

                idx = 0;
                continue;
            }
        }

        if (idx == 7) {
            ++stack_index;

            if (stack_index >= float_mantissa_size) {
                return total_color;
            }

            parent_idx = node_stack[stack_index];
            idx = child_index_stack[stack_index];
            side = side_stack[stack_index];

            parent = model.nodes[parent_idx];
        }

        pos -= mod(pos, side * 2.0);
        ++idx;
        pos += mix(vec3(0), vec3(side), notEqual(uvec3(idx) & uvec3(4, 2, 1), uvec3(0)));
    }

    return vec4(0, 1, 0, 1);
}

void main() {
    uvec2 index = gl_GlobalInvocationID.xy;

    if (any(greaterThanEqual(index, uniforms.output_region.extent))) {
        return;
    }

    ivec2 pixel = uniforms.output_region.offset + ivec2(index);
    vec2 uv = vec2(pixel - uniforms.display_region.offset) / vec2(uniforms.display_region.extent);

    vec3 ro = push.camera.translation.xyz + vec3(1);
    vec3 rd = ray(push.camera.forward.xyz, push.camera.up.xyz, uv);

    vec4 color = trace(ro, rd);

    imageStore(render_target, ivec2(index), vec4(color.rgb, 1));
}
