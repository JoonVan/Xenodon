#version 450

struct Node {
    uint children[8];
    uint color;
    uint is_leaf_depth;
};

struct Rect {
    ivec2 offset;
    uvec2 extent;
};

layout(local_size_x = 4, local_size_y = 4) in;

layout(push_constant) uniform PushConstant {
    float time;
} push;

layout(binding = 0) readonly uniform UniformBuffer {
    Rect output_region;
    Rect display_region;
} uniforms;

layout(binding = 1) readonly buffer Octree {
    Node nodes[];
} model;

layout(binding = 2, rgba8) restrict writeonly uniform image2D render_target;

const uint LEAF = 1 << 31;
const float EPSILON = 0.0001;

vec4 unpack(uint v) {
    return vec4(
        float(v & 0xFF) / 255.0,
        float((v >> 8) & 0xFF) / 255.0,
        float((v >> 16) & 0xFF) / 255.0,
        float((v >> 24) & 0xFF) / 255.0
    );
}

vec3 ray(vec3 dir, vec3 up, vec2 uv) {
    uv -= 0.5;
    uv.y *= float(uniforms.display_region.extent.y) / float(uniforms.display_region.extent.x);

    vec3 right = normalize(cross(up, dir));
    up = normalize(cross(right, dir));

    return normalize(uv.x * right + uv.y * up + dir);
}

float v3min(vec3 v) {
    return min(v.x, min(v.y, v.z));
}

float v3max(vec3 v) {
    return max(v.x, max(v.y, v.z));
}

vec2 aabb_intersect(vec3 bmin, vec3 bmax, vec3 ro, vec3 rrd) {
    vec3 tbot = (bmin - ro) * rrd;
    vec3 ttop = (bmax - ro) * rrd;
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);
    float t0 = v3max(tmin);
    float t1 = v3min(tmax);
    return vec2(t0, t1);
}

vec4 trace(vec3 ro, vec3 rd) {
    const uint cast_stack_depth = 23;
    const float epsilon = exp2(-float(cast_stack_depth));

    // Adjust the ray direction if one of its values is close to 0
    rd = mix(rd, step(rd, vec3(0)) * epsilon * 2.0 - epsilon, lessThan(abs(rd), vec3(epsilon)));

    vec3 rrd = 1.0 / abs(rd);
    vec3 bias = rrd * ro;

    // If the rd is less than 0, reflect the point around the cube
    // This way, a * rrd - bias is always smaller than b * rrd - bias, given a < b
    // if the ray hits the cube, and larger if the ray misses the cube
    bvec3 lt0 = lessThan(rd, vec3(0));
    bias = mix(bias, rrd * (3 - ro), lt0);

    vec3 a = rrd - bias;
    vec3 b = 2.0 * rrd - bias;

    float t_min = v3max(a);
    float t_max = v3min(b);

    if (t_min <= t_max) {
        return vec4(0);
    } else {
        return vec4(1, 0, 1, 1);
    }
}

void main() {
    uvec2 index = gl_GlobalInvocationID.xy;

    if (any(greaterThanEqual(index, uniforms.output_region.extent))) {
        return;
    }

    ivec2 pixel = uniforms.output_region.offset + ivec2(index);
    vec2 uv = vec2(pixel - uniforms.display_region.offset) / vec2(uniforms.display_region.extent);

    float t = push.time * 1.2;
    vec3 center = vec3(1.5, 1.25, 1.5);

    vec3 ro = center + vec3(sin(t), 0, cos(t)) * 3;
    vec3 rd = normalize(center - ro);
    rd = ray(rd, vec3(0, 1, 0), uv);

    vec4 color = trace(ro, rd);

    imageStore(render_target, ivec2(index), vec4(color.rgb, 1));
}
